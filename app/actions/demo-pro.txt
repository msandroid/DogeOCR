"use server"

import { z } from "zod"
import { 
  detectDocumentType, 
  generateInternationalPrompt, 
  getDocumentSchema,
  analyzeDocumentStructure,
  getDocumentCategory,
  COMPREHENSIVE_DOCUMENT_SCHEMAS,
  type DocumentType 
} from "./document-types"

// 拡張されたOCR結果の型定義
const AdvancedOcrOutputSchema = z.object({
  extractedText: z.string().describe("抽出されたテキスト"),
  documentType: z.string().describe("検出された文書種別"),
  documentCategory: z.string().describe("文書カテゴリ"),
  structuredData: z.record(z.any()).optional().describe("構造化データ"),
  processingTime: z.number().describe("処理時間（ミリ秒）"),
  apiVersion: z.string().default("v2.0"),
  confidence: z.number().min(0).max(1).describe("認識率"),
  language: z.string().describe("検出された言語"),
  documentStructure: z.object({
    hasTable: z.boolean(),
    hasSignature: z.boolean(),
    hasPhoto: z.boolean(),
    hasBarcode: z.boolean(),
    structure: z.string()
  }).describe("文書構造分析"),
  fieldConfidence: z.record(z.number().min(0).max(1)).optional().describe("フィールド別信頼度"),
  validationErrors: z.array(z.string()).optional().describe("検証エラー"),
  recommendations: z.array(z.string()).optional().describe("改善提案")
})

export async function handleImageUpload(
  prevState: { imagePreview: string | null; ocrResult: any },
  formData: FormData,
): Promise<{ imagePreview: string | null; ocrResult: any }> {
  const startTime = Date.now()
  
  const fireworksApiKey = process.env.FIREWORKS_API_KEY
  if (!fireworksApiKey) {
    return {
      imagePreview: null,
      ocrResult: {
        error: "APIキーが設定されていません。環境変数 FIREWORKS_API_KEY を確認してください。",
        processingTime: Date.now() - startTime,
      },
    }
  }

  const file = formData.get("image") as File
  const userPrompt = formData.get("chatPrompt") as string | null
  const targetLanguage = formData.get("language") as string || "ja"
  const documentHint = formData.get("documentHint") as string | null

  if (!file || file.size === 0) {
    return { 
      imagePreview: null, 
      ocrResult: { 
        error: "画像ファイルが提供されていません。",
        processingTime: Date.now() - startTime,
      } 
    }
  }

  // 画像ファイルのみを受け付ける
  if (!file.type.startsWith('image/')) {
    return { 
      imagePreview: null, 
      ocrResult: { 
        error: "画像ファイルのみ対応しています。JPG、PNG、GIF、WEBP形式の画像をアップロードしてください。",
        processingTime: Date.now() - startTime,
      } 
    }
  }

  const arrayBuffer = await file.arrayBuffer()
  const buffer = Buffer.from(arrayBuffer)
  const imagePreview = `data:${file.type};base64,${buffer.toString("base64")}`

  // 段階的OCR処理
  let ocrResult: object | null = null

  try {
    // Stage 1: 基本的なテキスト抽出とドキュメントタイプ検出
    const initialPrompt = userPrompt && userPrompt.trim().length > 0 
      ? userPrompt.trim()
      : "この画像からテキストを抽出し、文書の種類を特定してください。"

    const initialResponse = await performOCR(imagePreview, initialPrompt, fireworksApiKey)
    const extractedText = extractedResponse(initialResponse)
    
    if (!extractedText) {
      throw new Error("初期OCRで文字を抽出できませんでした。")
    }

    // 文書タイプの検出
    const detectedType = documentHint as DocumentType | "不明" || detectDocumentType(extractedText)
    const documentCategory = detectedType !== "不明" ? getDocumentCategory(detectedType) : "UNKNOWN"
    const documentStructure = analyzeDocumentStructure(extractedText)

    // Stage 2: 文書タイプに特化した詳細OCR
    let structuredData = null
    let fieldConfidence = {}
    let validationErrors: string[] = []
    
    if (detectedType !== "不明") {
      const specializedPrompt = generateInternationalPrompt(detectedType, targetLanguage)
      const specializedResponse = await performOCR(imagePreview, specializedPrompt, fireworksApiKey)
      const specializedResult = parseStructuredResponse(specializedResponse)
      
      if (specializedResult) {
        structuredData = specializedResult.extracted_data || specializedResult
        
        // バリデーション
        const schema = getDocumentSchema(detectedType)
        const validation = schema.safeParse(structuredData)
        
        if (!validation.success) {
          validationErrors = validation.error.issues.map(issue => 
            `${issue.path.join('.')}: ${issue.message}`
          )
        }

        // フィールド別信頼度の計算
        fieldConfidence = calculateFieldConfidence(structuredData, extractedText)
      }
    }

    // 改善提案の生成
    const recommendations = generateRecommendations(
      detectedType, 
      documentStructure, 
      validationErrors.length
    )

    const processingTime = Date.now() - startTime

    // 最終結果の組み立て
    const finalResult = {
      extractedText,
      documentType: detectedType,
      documentCategory,
      structuredData,
      processingTime,
      apiVersion: "v2.0",
      confidence: calculateOverallConfidence(fieldConfidence),
      language: documentStructure.language,
      documentStructure,
      fieldConfidence,
      validationErrors: validationErrors.length > 0 ? validationErrors : undefined,
      recommendations: recommendations.length > 0 ? recommendations : undefined
    }

    const validationResult = AdvancedOcrOutputSchema.safeParse(finalResult)
    
    ocrResult = validationResult.success
      ? validationResult.data
      : {
          error: "OCR結果の形式が期待と異なります。",
          details: validationResult.error.flatten(),
          extractedText,
          processingTime,
        }

  } catch (error: any) {
    ocrResult = {
      error: `OCR処理中にエラーが発生しました。詳細: ${
        error instanceof Error ? error.message : String(error)
      }`,
      processingTime: Date.now() - startTime,
    }
  }

  return { imagePreview, ocrResult }
}

// OCR実行の共通関数
async function performOCR(imagePreview: string, prompt: string, apiKey: string) {
  const requestBody = {
    model: "accounts/fireworks/models/firesearch-ocr-v6",
    max_tokens: 2048,
    top_p: 1,
    top_k: 40,
    presence_penalty: 0,
    frequency_penalty: 0,
    temperature: 0.1,
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text: prompt,
          },
          {
            type: "image_url",
            image_url: {
              url: imagePreview,
            },
          },
        ],
      },
    ],
  }

  const response = await fetch("https://api.fireworks.ai/inference/v1/chat/completions", {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify(requestBody),
  })

  if (!response.ok) {
    const errorData = await response.json().catch(() => response.text())
    throw new Error(`APIリクエストが失敗しました: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`)
  }

  return await response.json()
}

// レスポンスからテキストを抽出
function extractedResponse(data: any): string | null {
  const rawContent = data.choices?.[0]?.message?.content
  return typeof rawContent === "string" ? rawContent : null
}

// 構造化レスポンスの解析
function parseStructuredResponse(data: any): any {
  const rawContent = data.choices?.[0]?.message?.content
  
  if (typeof rawContent !== "string") {
    return null
  }

  try {
    // JSONブロックを抽出
    const jsonMatch = rawContent.match(/```json\s*([\s\S]*?)\s*```/) || 
                     rawContent.match(/```\s*([\s\S]*?)\s*```/) ||
                     [null, rawContent]
    
    if (jsonMatch && jsonMatch[1]) {
      return JSON.parse(jsonMatch[1].trim())
    } else {
      return JSON.parse(rawContent.trim())
    }
  } catch (jsonError) {
    // JSON解析に失敗した場合は部分的なパース試行
    return parsePartialJson(rawContent)
  }
}

// 部分的なJSON解析（エラー耐性）
function parsePartialJson(text: string): any {
  try {
    // 一般的なパターンを試行
    const cleanedText = text
      .replace(/```json|```/g, '')
      .replace(/^\s*\{/, '{')
      .replace(/\}\s*$/, '}')
      .trim()
    
    return JSON.parse(cleanedText)
  } catch {
    // 最後の手段：キーバリューペアの抽出
    const extracted: any = {}
    const patterns = [
      /"([^"]+)":\s*"([^"]*)"/g,
      /"([^"]+)":\s*([^,}\]]+)/g
    ]
    
    for (const pattern of patterns) {
      let match
      while ((match = pattern.exec(text)) !== null) {
        extracted[match[1]] = match[2].replace(/"/g, '').trim()
      }
    }
    
    return Object.keys(extracted).length > 0 ? extracted : null
  }
}

// フィールド別信頼度の計算
function calculateFieldConfidence(structuredData: any, originalText: string): Record<string, number> {
  const confidence: Record<string, number> = {}
  
  if (!structuredData || typeof structuredData !== 'object') {
    return confidence
  }

  const lowerText = originalText.toLowerCase()
  
  for (const [key, value] of Object.entries(structuredData)) {
    if (typeof value === 'string' && value.length > 0) {
      // 値がオリジナルテキストに含まれているかチェック
      const isPresent = lowerText.includes(value.toLowerCase())
      
      // 長さと文字種による信頼度調整
      const lengthFactor = Math.min(value.length / 10, 1)
      const alphanumericFactor = /[a-zA-Z0-9]/.test(value) ? 1 : 0.8
      
      confidence[key] = isPresent 
        ? Math.min(0.95, 0.7 + lengthFactor * 0.2 + alphanumericFactor * 0.05)
        : 0.3
    } else if (Array.isArray(value) && value.length > 0) {
      confidence[key] = 0.8
    } else if (value === null || value === undefined || value === '') {
      confidence[key] = 0.1
    } else {
      confidence[key] = 0.6
    }
  }
  
  return confidence
}

// 全体的な信頼度の計算
function calculateOverallConfidence(fieldConfidence: Record<string, number>): number {
  const values = Object.values(fieldConfidence)
  
  if (values.length === 0) {
    return 0.5
  }
  
  const average = values.reduce((sum, val) => sum + val, 0) / values.length
  return Math.round(average * 100) / 100
}

// 改善提案の生成
function generateRecommendations(
  documentType: DocumentType, 
  structure: any, 
  errorCount: number
): string[] {
  const recommendations: string[] = []
  
  if (documentType === "不明") {
    recommendations.push("文書タイプが特定できませんでした。より鮮明な画像をお試しください。")
  }
  
  if (errorCount > 0) {
    recommendations.push("一部のフィールドで検証エラーがあります。データを手動で確認してください。")
  }
  
  if (!structure.hasPhoto && ["パスポート", "運転免許証", "国民IDカード"].includes(documentType)) {
    recommendations.push("身分証明書ですが、写真が検出されませんでした。写真部分が含まれているか確認してください。")
  }
  
  if (structure.hasTable) {
    recommendations.push("表形式のデータが検出されました。構造化データを確認して、表の内容が正しく抽出されているかチェックしてください。")
  }
  
  if (structure.language !== "ja" && structure.language !== "en") {
    recommendations.push(`${structure.language}言語が検出されました。対応言語での処理を検討してください。`)
  }
  
  return recommendations
}

// 新しい文書タイプ検出API（フロントエンド用）
export async function detectDocumentTypeFromImage(
  imageBase64: string
): Promise<{
  documentType: DocumentType
  confidence: number
  category: string
  structure: any
}> {
  try {
    const fireworksApiKey = process.env.FIREWORKS_API_KEY
    if (!fireworksApiKey) {
      throw new Error("APIキーが設定されていません。")
    }

    const prompt = "この画像の文書タイプを特定してください。簡潔に文書の種類のみを回答してください。"
    const response = await performOCR(imageBase64, prompt, fireworksApiKey)
    const extractedText = extractedResponse(response)
    
    if (!extractedText) {
      throw new Error("文字を抽出できませんでした。")
    }

    const documentType = detectDocumentType(extractedText)
    const structure = analyzeDocumentStructure(extractedText)
    
    return {
      documentType,
      confidence: documentType === "不明" ? 0.3 : 0.8,
      category: getDocumentCategory(documentType),
      structure
    }
  } catch (error) {
    return {
      documentType: "不明",
      confidence: 0.1,
      category: "UNKNOWN",
      structure: {
        hasTable: false,
        hasSignature: false,
        hasPhoto: false,
        hasBarcode: false,
        language: "unknown",
        structure: "unknown"
      }
    }
  }
}

// バッチ処理API（複数画像対応）
export async function handleMultipleImages(
  imageFiles: File[]
): Promise<any[]> {
  const results = []
  
  for (const file of imageFiles) {
    const formData = new FormData()
    formData.append("image", file)
    
    const result = await handleImageUpload(
      { imagePreview: null, ocrResult: null },
      formData
    )
    
    results.push({
      filename: file.name,
      ...result
    })
  }
  
  return results
}

// 文書検証API
export async function validateDocumentData(
  documentType: DocumentType,
  extractedData: any
): Promise<{
  isValid: boolean
  errors: string[]
  warnings: string[]
  completeness: number
}> {
  try {
    if (documentType === "不明") {
      return {
        isValid: false,
        errors: ["文書タイプが不明のため、検証できません"],
        warnings: [],
        completeness: 0
      }
    }

    const schema = getDocumentSchema(documentType)
    const validation = schema.safeParse(extractedData)
    
    const errors: string[] = []
    const warnings: string[] = []
    
    if (!validation.success) {
      errors.push(...validation.error.issues.map(issue => 
        `${issue.path.join('.')}: ${issue.message}`
      ))
    }
    
    // 必須フィールドの完成度チェック  
    const requiredFields = getRequiredFieldsForDocument(documentType)
    const presentFields = Object.keys(extractedData).filter(key => 
      extractedData[key] !== null && 
      extractedData[key] !== undefined && 
      extractedData[key] !== ''
    )
    
    const completeness = requiredFields.length > 0 
      ? presentFields.length / requiredFields.length 
      : 1
    
    // 警告の生成
    if (completeness < 0.8) {
      warnings.push("重要なフィールドの一部が抽出されていません。")
    }
    
    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      completeness: Math.round(completeness * 100) / 100
    }
  } catch (error) {
    return {
      isValid: false,
      errors: [`検証エラー: ${error instanceof Error ? error.message : String(error)}`],
      warnings: [],
      completeness: 0
    }
  }
}

// 文書タイプ別の必須フィールドを取得
function getRequiredFieldsForDocument(documentType: DocumentType): string[] {
  const requiredFieldsMap: Record<string, string[]> = {
    "パスポート": ["passport_number", "surname", "given_names", "nationality", "date_of_birth"],
    "運転免許証": ["license_number", "full_name", "date_of_birth", "address"],
    "請求書": ["invoice_number", "invoice_date", "total_amount"],
    "名刺": ["name", "company"],
    "診断書": ["patient_name", "doctor_name", "diagnosis_date"],
    "不明": []
  }
  
  return requiredFieldsMap[documentType] || []
}
